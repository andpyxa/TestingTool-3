&НаКлиенте
Перем КешСтеммераПортера;
&НаКлиенте
Перем Модуль_СтеммерПортера;
&НаКлиенте
Перем Модуль_ОбработкаТекста;
&НаКлиенте
Перем КешРасчетныхДанных;
&НаКлиенте
Перем КешСжатыхВекторов;
&НаКлиенте
Перем КешДанныхСжатыхВекторов;
&НаКлиенте
Перем вхНастройка;


&НаСервере
Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
	//Вставить содержимое обработчика
КонецПроцедуры

&НаКлиенте
Процедура ПриОткрытии(Отказ)
	//Вставить содержимое обработчика
КонецПроцедуры

#Область Математика

// Функция - Получить косинус между двумя векторами
//
// Параметры:
//  вхВектор1	 - список значений/массив - первый вектор
//  вхВектор2	 - список значений/массив - второй вектор
// 
// Возвращаемое значение:
// число  - результат перемножения векторов, если у одного (обоих) векторов длина равно 0 (нулевой вектор), то резултат будет -999999999.
//
&НаКлиенте
Функция ПолучитьКосинусВекторов(вхВектор1, Ключ1, вхВектор2, Ключ2, мКешПараметры) Экспорт
	
	Косинус = 0;
	
	Вектор1 = мКешПараметры.КешДанныхСжатыхВекторов.Получить(Ключ1);
	Если Вектор1=Неопределено Тогда
		Если ТипЗнч(вхВектор1)=Тип("СписокЗначений") Тогда
			Вектор1 = вхВектор1.ВыгрузитьЗначения();
		Иначе
			Вектор1 = вхВектор1;
		КонецЕсли;
		Если НЕ Ключ1=Неопределено Тогда
			мКешПараметры.КешДанныхСжатыхВекторов.Вставить(Ключ1,Вектор1);
		КонецЕсли;
	КонецЕсли;
	
	Вектор2 = мКешПараметры.КешДанныхСжатыхВекторов.Получить(Ключ2);
	Если Вектор2=Неопределено Тогда
		Если ТипЗнч(вхВектор2)=Тип("СписокЗначений") Тогда
			Вектор2 = вхВектор2.ВыгрузитьЗначения();
		Иначе
			Вектор2 = вхВектор2;
		КонецЕсли;			
		Если НЕ Ключ2=Неопределено Тогда
			мКешПараметры.КешДанныхСжатыхВекторов.Вставить(Ключ2,Вектор2);
		КонецЕсли;
	КонецЕсли;
	
	ПроизведениеВекторов = 0;
	
	// оптимизация
	СжатыйВектор1 = мКешПараметры.КешСжатыхВекторов.Получить(Ключ1);
	Если СжатыйВектор1=Неопределено Тогда
		СжатыйВектор1 = СжатьВектор(Вектор1,Ключ1);
		Если НЕ Ключ1=Неопределено Тогда
			мКешПараметры.КешСжатыхВекторов.Вставить(Ключ1,СжатыйВектор1);
		КонецЕсли;
	КонецЕсли;
	СжатыйВектор2 = мКешПараметры.КешСжатыхВекторов.Получить(Ключ2);
	Если СжатыйВектор2=Неопределено Тогда
		СжатыйВектор2 = СжатьВектор(Вектор2,Ключ2);
		Если НЕ Ключ2=Неопределено Тогда
			мКешПараметры.КешСжатыхВекторов.Вставить(Ключ2,СжатыйВектор2);
		КонецЕсли;
	КонецЕсли;
	
	ДлинаВектор1 = ПолучитьДлинуВектора(СжатыйВектор1,Ключ1,мКешПараметры);
	ДлинаВектор2 = ПолучитьДлинуВектора(СжатыйВектор2,Ключ2,мКешПараметры);
	
	Если ДлинаВектор1=0 ИЛИ ДлинаВектор2=0 Тогда
		Возврат -999999999;
	КонецЕсли;
	                  	
	
	БольшийВектор = Неопределено;
	МенишийВектор = Неопределено;
	Если СжатыйВектор1.Количество()>СжатыйВектор2.Количество() Тогда
		МенишийВектор=СжатыйВектор2;
		БольшийВектор=СжатыйВектор1;
	Иначе
		МенишийВектор=СжатыйВектор1;
		БольшийВектор=СжатыйВектор2;
	КонецЕсли;
	
	Для каждого ш из МенишийВектор Цикл
		ж = БольшийВектор.Получить(ш.Ключ);
		Если ж=Неопределено Тогда
			Продолжить;
		КонецЕсли;
		ПроизведениеВекторов = ПроизведениеВекторов + ш.Значение*ж;
	КонецЦикла;
	
	Косинус = Окр(ПроизведениеВекторов/(ДлинаВектор1*ДлинаВектор2),5,РежимОкругления.Окр15как20);
	
	Возврат Косинус;
	
КонецФункции

&НаКлиенте
Функция ПолучитьДлинуВектора(Знач Вектор1, Знач Ключ, мКешПараметры)  Экспорт
	
	ДлинаВектора = Неопределено;
	Если НЕ Ключ=Неопределено Тогда
		ДлинаВектора = мКешПараметры.КешРасчетныхДанных.Получить(Ключ);
	КонецЕсли;
	
	Если ДлинаВектора=Неопределено Тогда	
		ДлинаВектора= 0;
		Для каждого стр из Вектор1 Цикл
			ДлинаВектора = ДлинаВектора+стр.Значение*стр.Значение;
		КонецЦикла;
		ДлинаВектора = Окр(ДлинаВектора,5,РежимОкругления.Окр15как20);
		Если НЕ Ключ=Неопределено Тогда
			мКешПараметры.КешРасчетныхДанных.Вставить(Ключ,ДлинаВектора);
		КонецЕсли;
	Конецесли;
	
	Возврат  Sqrt(ДлинаВектора);
	
КонецФункции

&НаКлиенте
Функция СжатьВектор(Вектор,Ключ) Экспорт
	СжатыйВекторРезультат = новый Соответствие;
	
	Для ш=0 по Вектор.Количество()-1 Цикл
		Если Вектор[ш].Значение=0 Тогда
			Продолжить;
		КонецЕсли;
		СжатыйВекторРезультат.Вставить(ш,Вектор[ш].Значение);
	КонецЦикла;
	
	Возврат СжатыйВекторРезультат;
КонецФункции

#КонецОбласти

#Область Подготовка



&НаКлиенте
Процедура ПодготовитьБазис(Знач МассивСтруктурТекстов, мНастройка) Экспорт
	
	// инициализация
	ЗагрузитьБиблиотеки();
	
	// формируем текст общий
	Текст = "";
	Для каждого стр из МассивСтруктурТекстов Цикл
		Если НЕ ЗначениеЗаполнено(стр.Текст) Тогда
			Продолжить;
		КонецЕсли;
		Текст = Текст+" "+стр.Текст+" END_OF_TEXT_PARAGRAF ";
	КонецЦикла;
	
	// обработка текста
	ОбработанныйТекст = Модуль_ОбработкаТекста.ОбработатьТекстДанных(Текст,мНастройка); 	
	
	// формируем корпус текстов
	ЗаполнитьТаблицуКорпусаТекстовПоТекущемуТексту(МассивСтруктурТекстов,Текст,ОбработанныйТекст,мНастройка); 
	
	// формируем базис
	ПолучитьЧастотность(ОбработанныйТекст,мНастройка);
	
	// 
	// ВекторСловСписком
	Если мНастройка.Свойство("БазисСлов") Тогда
		мНастройка.Вставить("ВекторСловСписком",СформироватьВекторСловСписком(мНастройка.БазисСлов));
	Иначе
		мНастройка.Вставить("ВекторСловСписком",СформироватьВекторСловСписком(БазисСлов));
	КонецЕсли;
	// КешРасчетныхДанных
	мНастройка.Вставить("КешРасчетныхДанных",новый Соответствие);
	// КешСжатыхВекторов
	мНастройка.Вставить("КешСжатыхВекторов",новый Соответствие);
	// КешДанныхСжатыхВекторов
	мНастройка.Вставить("КешДанныхСжатыхВекторов",новый Соответствие);
	
	// таблица векторов
	СформироватьТаблицуВекторов(мНастройка);
	                 	
	// считаем вектор
	РассчитатьВекторноеПространство(мНастройка);
	
	вхНастройка = мНастройка;
	
КонецПроцедуры

&НаКлиенте
Процедура ПолучитьЧастотность(ОбработанныйТекст,мНастройка)
	
	КешБазисныхСлов = новый Соответствие;
	ТекстДляРазбора = СтрЗаменить(ОбработанныйТекст,нрег("END_OF_TEXT_PARAGRAF")," ");
	МассивСлов = СтрРазделить(ТекстДляРазбора," ",Ложь);
	
	ЧастотаСлов = новый Соответствие;
	
	Для каждого стр из МассивСлов Цикл
		
		Если СтрДлина(стр)<3 Тогда
			Продолжить;
		КонецЕсли;
		
		Количество = ЧастотаСлов.Получить(стр);
		
		Если Количество=Неопределено Тогда
			ЧастотаСлов.Вставить(стр,1);
		Иначе
			ЧастотаСлов.Вставить(стр,Количество+1);
		КонецЕсли;
		
	КонецЦикла;
	
	БазисСлов.Очистить();
	Для каждого стр из ЧастотаСлов Цикл
		стр_н = БазисСлов.Добавить();
		стр_н.Слово = стр.Ключ;
		стр_н.Частота = стр.Значение;
		стр_н.guid = Строка(новый UUID());
	КонецЦикла;
	
	БазисСлов.Сортировать("Частота Убыв");
	
КонецПроцедуры

&НаКлиенте
Функция ПолучитьРазмерностьВектора() Экспорт
	Возврат БазисСлов.Количество();
КонецФункции

&НаКлиенте
Процедура СформироватьТаблицуВекторов(мНастройка)
	
	КешДанныхСжатыхВекторов = новый Соответствие;
	КешСжатыхВекторов = новый Соответствие;
	КешРасчетныхДанных = новый Соответствие;
	КешБазисныхСлов = новый Соответствие;

	ТаблицаСвязиСловДокументов.Очистить();
	
	// вектор списка значений
	//мНастройка.ВекторСловСписком = новый СписокЗначений;
	//
	//Для каждого Слово из БазисСлов Цикл
	//	Структура = новый Структура("Слово,Количество,КоличествоСлов,КоличествоДокументовЭтоСлово,TF,IDF,TFIDF,Значение",Слово.Слово,0,0,0,0,0,0,0);
	//	ВекторСловСписком.Добавить(Структура,Слово.Слово);
	//КонецЦикла;
	//// отсортируем
	//ВекторСловСписком.СортироватьПоЗначению(НаправлениеСортировки.Возр);
	
	Для каждого Док из ТаблицаКорпусТекстов Цикл
		стр_н = ТаблицаСвязиСловДокументов.Добавить();
		стр_н.Документ = Док.НомерДокумента;
		стр_н.guid_Документ = Док.guid;
		стр_н.Вектор = мНастройка.ВекторСловСписком.Скопировать();
		Для каждого стр из стр_н.Вектор Цикл
			стр.Значение = новый Структура("Слово,Количество,КоличествоСлов,КоличествоДокументовЭтоСлово,TF,IDF,TFIDF,Значение",стр.Представление,0,0,0,0,0,0,0);
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры

&НаКлиенте
Процедура РассчитатьВекторноеПространство(мНастройка)
	
	
	СоответсвиеБазисСлов = новый Соответствие;
	СоответсвиеСлов = новый Соответствие;
	КоличествоДокументов = ТаблицаКорпусТекстов.Количество();
	КоличествоСловВДокументе = новый Соответствие;
	КешТаблицыСвязей = новый Соответствие;
	КешВекторСловСписком = новый Соответствие;
	Текст_НеИспользоватьIDF = Ложь;
	мНастройка.Свойство("Текст_НеИспользоватьIDF",Текст_НеИспользоватьIDF);
	// TODO: требуется сброс векторов, иначе будут кривится данные - по крайней мере количество слов в текущем документе
	
	
	Для каждого стр из БазисСлов Цикл
		СоответсвиеБазисСлов.Вставить(стр.Слово,стр);
	КонецЦикла;
	
	Для каждого стр из мНастройка.ВекторСловСписком Цикл
		КешВекторСловСписком.Вставить(стр.Представление,стр);
	КонецЦикла;
	
	Для каждого стр из ТаблицаСвязиСловДокументов Цикл
		КешТаблицыСвязей.Вставить(стр.guid_Документ,стр);
	КонецЦикла;
	
	КешСловСоответствияВекторуСписка = новый Соответствие;
	
	Для каждого стр из мНастройка.ВекторСловСписком Цикл
		КешСловСоответствияВекторуСписка.Вставить(стр.Представление,мНастройка.ВекторСловСписком.Индекс(стр));
	КонецЦикла;
	
	// посчитаем количество слов в документе
	Для каждого Документ из ТаблицаКорпусТекстов Цикл
		
		МассивСлов = СтрРазделить(Документ.ОбработанныйТекст," ",Ложь);
		//МассивСлов = ОбработатьМассивАлгоритмомСтеммингПриНеобходимости(МассивСлов);
		Документ.КоличествоСлов = МассивСлов.Количество();
		ДокСвязи = КешТаблицыСвязей.Получить(Документ.guid);
		КешУжеВстретившихсяСлов = новый Соответствие;
		
		Для каждого Слово из МассивСлов Цикл
			Слово = СокрЛП(Слово);
			Индекс = КешСловСоответствияВекторуСписка.Получить(Слово);
			Если Индекс=Неопределено Тогда
				Продолжить;
			КонецЕсли;
			стр = ДокСвязи.Вектор.Получить(Индекс).Значение;
			стр.Количество = стр.Количество+1;
			стр.КоличествоСлов = Документ.КоличествоСлов;
			
			// количество в документах
			Если КешУжеВстретившихсяСлов.Получить(Слово)=Неопределено Тогда
				КешУжеВстретившихсяСлов.Вставить(Слово,Истина);
				ВстречаетсяВДокументе = КоличествоСловВДокументе.Получить(Слово);
				Если ВстречаетсяВДокументе=Неопределено Тогда
					КоличествоСловВДокументе.Вставить(Слово,1);
				Иначе
					КоличествоСловВДокументе.Вставить(Слово,ВстречаетсяВДокументе+1);
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
		
	КонецЦикла;
	
	Если Текст_НеИспользоватьIDF=Истина Тогда
		
		// посчитаем TF
		Для каждого Док из ТаблицаСвязиСловДокументов Цикл
			Для каждого эл из Док.Вектор Цикл
				стр = эл.Значение;
				стр.IDF =  1;
				ВстречаетсяВДокументе = КоличествоСловВДокументе.Получить(стр.Слово);
				Если НЕ ВстречаетсяВДокументе=Неопределено Тогда
					стр.КоличествоДокументовЭтоСлово = ВстречаетсяВДокументе;
				КонецЕсли;	
				Если стр.КоличествоСлов=0 ИЛИ стр.Количество=0 Тогда
					Продолжить;
				КонецЕсли;
				стр.TF=стр.Количество/стр.КоличествоСлов;
				стр.TFIDF = стр.TF*стр.IDF;
				стр.Значение = стр.TFIDF;
			КонецЦикла;
		КонецЦикла;
		
		
	Иначе
		
		Для каждого стр из КоличествоСловВДокументе Цикл
			сл = СоответсвиеБазисСлов.Получить(стр.Ключ);
			Если сл=Неопределено Тогда
				Продолжить;
			КонецЕсли;
			сл.КоличествоДокументовЭтоСлово = стр.Значение;
			сл.IDF = Log10(КоличествоДокументов/сл.КоличествоДокументовЭтоСлово);
			век = КешВекторСловСписком.Получить(стр.Ключ);
			век.Значение.КоличествоДокументовЭтоСлово = стр.Значение;
		КонецЦикла;
		
		
		// посчитаем TF
		Для каждого Док из ТаблицаСвязиСловДокументов Цикл
			Для каждого эл из Док.Вектор Цикл
				стр = эл.Значение;
				ВстречаетсяВДокументе = КоличествоСловВДокументе.Получить(стр.Слово);
				Если НЕ ВстречаетсяВДокументе=Неопределено Тогда
					стр.КоличествоДокументовЭтоСлово = ВстречаетсяВДокументе;
					стр.IDF =  Log10(КоличествоДокументов/стр.КоличествоДокументовЭтоСлово);
				КонецЕсли;	
				Если стр.КоличествоСлов=0 ИЛИ стр.Количество=0 Тогда
					Продолжить;
				КонецЕсли;
				стр.TF=стр.Количество/стр.КоличествоСлов;
				стр.TFIDF = стр.TF*стр.IDF;
				стр.Значение = стр.TFIDF;
			КонецЦикла;
		КонецЦикла;
		
	КонецЕсли;
	

КонецПроцедуры

&НаКлиенте
Процедура ЗаполнитьТаблицуКорпусаТекстовПоТекущемуТексту(МассивСтруктурТекстов,Текст,ОбработанныйТекст,мНастройки)
	
	ТаблицаКорпусТекстов.Очистить();
	
	ДанныеТекст = СтрЗаменить(Текст,"END_OF_TEXT_PARAGRAF",Символ(18));
	ДанныеТекст = СтрЗаменить(ДанныеТекст,нрег("END_OF_TEXT_PARAGRAF"),Символ(18));
	МассивТекстов = СтрРазделить(ДанныеТекст,Символ(18),Истина);
	
	ДанныеОбработанныйТекст = СтрЗаменить(ОбработанныйТекст,Символы.ПС," ");
	ДанныеОбработанныйТекст = СтрЗаменить(ДанныеОбработанныйТекст,"END_OF_TEXT_PARAGRAF",Символ(18));
	ДанныеОбработанныйТекст = СтрЗаменить(ДанныеОбработанныйТекст,нрег("END_OF_TEXT_PARAGRAF"),Символ(18));
	МассивОбработанныхТекстов = СтрРазделить(ДанныеОбработанныйТекст,Символ(18),Истина);
	
	ш=1;
	Для каждого стр из МассивОбработанныхТекстов Цикл

		Если НЕ ЗначениеЗаполнено(стр) Тогда
			Продолжить;
		КонецЕсли;
		стр_н = ТаблицаКорпусТекстов.Добавить();		
		стр_н.НомерДокумента = ш;
		стр_н.guid = Строка(новый uuid());
		стр_н.Текст = СокрЛП(МассивТекстов[ш-1]);
		стр_н.НижняяГраница = 0.3;
		стр_н.ВерхняяГраница = 0.86;
		стр_н.ОбработанныйТекст = ПолучитьКанонизированнуюСтроку(МассивОбработанныхТекстов[ш-1]);
		Если МассивСтруктурТекстов.Количество()>=ш Тогда
			стр_н.Ключ = МассивСтруктурТекстов[ш-1].Наименование;
		КонецЕсли;
		ш=ш+1;
	КонецЦикла;

КонецПроцедуры

&НаКлиенте
Функция ПолучитьКанонизированнуюСтроку(Знач Текст)
	
	ОбработаннаяТекстоваяСтрока = "";
	Текст = СтрЗаменить(Текст,Символы.ПС,"");
	МассивСлов = СтрРазделить(Текст," ",Ложь);
	
	Для каждого слово из МассивСлов Цикл
		Если НЕ ЗначениеЗаполнено(слово) Тогда
			Продолжить;
		КонецЕсли;
		ОбработаннаяТекстоваяСтрока = ОбработаннаяТекстоваяСтрока+ слово+ " ";
	КонецЦикла;
	
	Возврат ОбработаннаяТекстоваяСтрока;
КонецФункции

&НаКлиенте
Функция ПолучитьМассивВекторов(мНастройка) Экспорт
	
	МассивВекторов = новый Массив;
	СоответсвиеКорпусов = новый Соответствие;
	
	Для каждого стр из ТаблицаКорпусТекстов Цикл
		СоответсвиеКорпусов.Вставить(стр.guid,стр.Ключ);
	КонецЦикла;
	
	Для каждого стр из ТаблицаСвязиСловДокументов Цикл
		
		Ключ = СоответсвиеКорпусов.Получить(стр.guid_Документ);
		МассивВекторов.Добавить(новый структура("Ключ,Вектор",Ключ,стр.Вектор.ВыгрузитьЗначения()));
		
	КонецЦикла;	
	
	Возврат МассивВекторов;
	
КонецФункции

#КонецОбласти

#Область ОбработкаВекторноеПространство

&НаКлиенте	
Функция СформироватьВекторСловСписком(БазисСлов)
	// вектор списка значений
	ВекторСловСписком = новый СписокЗначений;
	
	Для каждого Слово из БазисСлов Цикл
		Структура = новый Структура("Слово,Количество,КоличествоСлов,КоличествоДокументовЭтоСлово,TF,IDF,TFIDF,Значение",Слово.Слово,0,0,0,0,0,0,0);
		ЗаполнитьЗначенияСвойств(Структура,Слово);
		ВекторСловСписком.Добавить(Структура,Слово.Слово);
	КонецЦикла;
	// отсортируем
	ВекторСловСписком.СортироватьПоЗначению(НаправлениеСортировки.Возр);
	
	Если ВекторСловСписком.Количество()=0 Тогда
		//ВызватьИсключение "Вектор для автоматической классификации не задан! Выполните настройки!";
	КонецЕсли;
	
	Возврат ВекторСловСписком;
КонецФункции

&НаКлиенте	
Функция ПолучитьВекторЗапроса(Текст,КоличествоДокументов,мНастройка) Экспорт
	
	Текст_НеИспользоватьIDF = Ложь;
	мНастройка.Свойство("Текст_НеИспользоватьIDF",Текст_НеИспользоватьIDF);
	ВекторЗапроса = новый Массив;
	
	Текст = " "+Текст+" ";
	
	// 1. Разберем слово
	ОбработанныйТекст = Модуль_ОбработкаТекста.ОбработатьТекстДанных(Текст,мНастройка);
	// 2. Составим вектор
	ОбработанныйТекст = СтрЗаменить(ОбработанныйТекст,Символы.ПС," ");
	//ОбработаннаяСтрокаЗапроса = УдалитьСловаНеВходящиеВБазис(ОбработаннаяСтрокаЗапроса);
	МассивСлов = СтрРазделить(ОбработанныйТекст," ",Ложь);
	
	КоличествоСловЗапроса = МассивСлов.Количество();
	Если КоличествоДокументов=0 Тогда
		КоличествоДокументов=1;
	КонецЕсли;
 	
	
	Для каждого эл из мНастройка.ВекторСловСписком Цикл
		стр = эл.Значение;
		
		Точка = новый Структура("Слово,Количество,КоличествоСлов,TF,IDF,TFIDF,Значение",стр.Слово,0,0,0,0,0,0);
		
		КоличествоВхождений = СтрЧислоВхождений(" "+ОбработанныйТекст+" "," "+стр.Слово+" ");		
		
		Если КоличествоВхождений>0 Тогда
			
			
			Точка.Количество = КоличествоВхождений;
			Точка.TF = КоличествоВхождений/КоличествоСловЗапроса;			
			Если стр.КоличествоДокументовЭтоСлово=0 Тогда
				стр.КоличествоДокументовЭтоСлово=1;
			КонецЕсли;			
			Если Текст_НеИспользоватьIDF=Истина Тогда
				Точка.IDF = 1;
			Иначе
				Точка.IDF =  Log10(КоличествоДокументов/стр.КоличествоДокументовЭтоСлово);
			КонецЕсли;
			Точка.TFIDF = Точка.IDF*Точка.TF;
			Точка.Значение = Точка.TFIDF;
		КонецЕсли;
		
		ВекторЗапроса.Добавить(Точка);
		
	КонецЦикла;	
	
	Возврат ВекторЗапроса;
	
КонецФункции

#КонецОбласти

#Область Проверка


&НаКлиенте
Функция ВыполнитьКлассификациюТекста(Текст,мНастройка) Экспорт
	
	РезультатКлассификации = новый Структура("КлассОсновной,КлассВторичный,КлючОсновной,КлючВторичный,КосинусОсновной,КосинусВторичный,СуждениеОсновной,СуждениеВторичный","","","","",0,0,"нет","нет");
	
	ТаблицаРезультатаБлизости.Очистить();
	КешОбработанныхСтрокКлассификатора = новый Соответствие;
	
	КлючОшибки = Неопределено;
	КлассОсновной = Неопределено;
	КлючОсновной = Неопределено;
	КлассВторичный = Неопределено;
	КлючВторичный = Неопределено;
	СуждениеОсновной = Неопределено;
	СуждениеВторичный = Неопределено;
	КосинусОсновной = 0;
	КосинусВторичный = 0;
	Суждение = "";
	
	ВекторЗапроса = ПолучитьВекторЗапроса(Текст,ТаблицаКорпусТекстов.Количество(),мНастройка);
	
	
	
	// 2) выполняем классификацию
	Для каждого класс из ТаблицаКорпусТекстов Цикл
		
		Если НЕ ЗначениеЗаполнено(класс.Текст) Тогда
			Продолжить;
		КонецЕсли;
		
		// 2.1) формируем вектор класса или берем из кеша
		КлючКласса = класс.НомерДокумента+"/"+класс.guid;
		ВекторКласса = КешОбработанныхСтрокКлассификатора.Получить(КлючКласса);
		Если ВекторКласса=Неопределено Тогда
			ВекторКласса = ПолучитьВекторЗапроса(класс.Текст,ТаблицаКорпусТекстов.Количество(),мНастройка);
			КешОбработанныхСтрокКлассификатора.Вставить(КлючКласса,ВекторКласса);
		КонецЕсли;
		
		
		// 2.2) получаем косинус
		Косинус = ПолучитьКосинусВекторов(ВекторКласса,КлючКласса,ВекторЗапроса,КлючОшибки,мНастройка);
		      				
		Если Косинус>класс.ВерхняяГраница Тогда
			Суждение = "совпадение";
		ИначеЕсли Косинус>класс.НижняяГраница Тогда
			Суждение = "возможно";
		Иначе
			Суждение = "нет";
		КонецЕсли;

		стр_н = ТаблицаРезультатаБлизости.Добавить();
		стр_н.Косинус = Косинус;
		стр_н.Текст = класс.Текст;
		стр_н.guid = класс.guid;
		стр_н.Документ = класс.НомерДокумента;
		стр_н.Суждение = Суждение;
		
		// 2.3) выполняем классификацию
		Если Косинус>класс.НижняяГраница Тогда
			
			Если КосинусОсновной<Косинус Тогда
				КосинусВторичный = КосинусОсновной;
				КлассВторичный = КлассОсновной;
				СуждениеВторичный = СуждениеОсновной;
				КлючВторичный = КлючОсновной;
				КосинусОсновной = Косинус;
				КлассОсновной = класс.Текст;
				СуждениеОсновной = Суждение;
				КлючОсновной = класс.Ключ;
			ИначеЕсли КосинусВторичный<Косинус Тогда
				КосинусВторичный = Косинус;
				КлассВторичный = класс.Текст;
				КлючВторичный = класс.Ключ;
				СуждениеВторичный =  Суждение;
			КонецЕсли;
			
		КонецЕсли;		
		
	КонецЦикла;
	
	СортировкаТаблицы();
	
	РезультатКлассификации.КлассОсновной = КлассОсновной;
	РезультатКлассификации.КлассВторичный = КлассВторичный;
	РезультатКлассификации.КлючОсновной = КлючОсновной;
	РезультатКлассификации.КлючВторичный = КлючВторичный;
	РезультатКлассификации.КосинусОсновной = КосинусОсновной;
	РезультатКлассификации.КосинусВторичный = КосинусВторичный;
	РезультатКлассификации.СуждениеОсновной = СуждениеОсновной;
	РезультатКлассификации.СуждениеВторичный = СуждениеВторичный;
	
	
	Возврат РезультатКлассификации;
КонецФункции

&НаКлиенте
Функция ПреобразоватьТекстВектор(Текст,мНастройка) Экспорт
	
	Возврат ПолучитьВекторЗапроса(Текст,ТаблицаКорпусТекстов.Количество(),мНастройка);
	
КонецФункции

&НаКлиенте
Процедура ПоискБлизкихДокументов(Команда)
	ВыполнитьКлассификациюТекста(СтрокаЗапроса,вхНастройка);
	ОбработаннаяСтрокаЗапроса = Модуль_ОбработкаТекста.ОбработатьТекстДанных(СтрокаЗапроса,вхНастройка);
КонецПроцедуры

&НаКлиенте
Процедура СортировкаТаблицы()
	
	ЕстьСдвиги = Истина;
	
	Пока ЕстьСдвиги=Истина Цикл
		ЕстьСдвиги = Ложь;
		Для ш =0 по ТаблицаРезультатаБлизости.Количество()-2 Цикл
			
			Если ТаблицаРезультатаБлизости[ш].Косинус<ТаблицаРезультатаБлизости[ш+1].Косинус Тогда
				ТаблицаРезультатаБлизости.Сдвинуть(ш,1);
				ЕстьСдвиги = Истина;
			КонецЕсли;
			
		КонецЦикла;
	КонецЦикла;

КонецПроцедуры

#КонецОбласти

&НаКлиенте
Функция ЗагрузитьБиблиотеки() Экспорт
	
	Если Модуль_СтеммерПортера=Неопределено Тогда
		Модуль_СтеммерПортера = ПолучитьФорму("ВнешняяОбработка.МенеджерСценарногоТеста.Форма.Модуль_СтеммерПортера");
	КонецЕсли;		
	
	Если Модуль_ОбработкаТекста=Неопределено Тогда
		Модуль_ОбработкаТекста = ПолучитьФорму("ВнешняяОбработка.МенеджерСценарногоТеста.Форма.Модуль_ОбработкаТекста");
	КонецЕсли;
	
КонецФункции


КешСтеммераПортера = новый Соответствие;
КешРасчетныхДанных = новый Соответствие;
КешСжатыхВекторов = новый Соответствие;
КешДанныхСжатыхВекторов = новый Соответствие;
